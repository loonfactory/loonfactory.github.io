---
layout: single
title:  "[백준 11536] 줄 세우기: Python 풀이 및 해설"
date:   2025-09-21 22:50:00 +0900
categories: [Algorithm, Baekjoon]
tags: [Implementation, String, Python]
---

**문제 링크:** [https://www.acmicpc.net/problem/11536](https://www.acmicpc.net/problem/11536)

## **1. 문제 개요**

주어진 N개의 이름 리스트가 다음 세 가지 상태 중 어떤 상태에 해당하는지 판별하는 문제입니다.

1. **INCREASING**: 모든 이름이 사전 순으로 오름차순 정렬된 상태
2. **DECREASING**: 모든 이름이 사전 순으로 내림차순 정렬된 상태
3. **NEITHER**: 위 두 가지 상태에 해당하지 않는, 정렬되지 않은 상태

## **2. 알고리즘 분석**

문제의 핵심은 리스트 전체의 **정렬 일관성**을 확인하는 것입니다. 전체 리스트를 정렬하여 비교하는 대신, 인접한 요소 간의 관계를 순차적으로 검사하는 것이 더 효율적입니다.

알고리즘은 다음과 같은 단계로 구성됩니다.

1. **초기 방향성 결정**: 리스트의 첫 두 요소(`words[0]`, `words[1]`)를 비교하여 리스트가 만족해야 할 잠재적 정렬 규칙(오름차순 또는 내림차순)을 설정합니다.
2. **일관성 검증**: 설정된 초기 방향성을 기준으로, 리스트의 나머지 요소들을 순회하며 인접한 모든 요소 쌍(`words[i]`, `words[i+1]`)이 동일한 방향성을 따르는지 검사합니다.
3. **조기 종료 (Early Exit)**: 검증 과정 중 단 한 번이라도 초기 방향성과 다른 순서가 발견되면, 해당 리스트는 `NEITHER` 상태로 즉시 판별할 수 있습니다. 이 경우, 더 이상의 탐색은 불필요하므로 연산을 중단합니다.
4. **최종 판별**: 반복문이 중단 없이 모두 실행되었다면, 리스트 전체가 초기 방향성을 만족하는 것이므로 `INCREASING` 또는 `DECREASING`으로 판별합니다.

## **3. 구현 전략**

본 풀이에서는 알고리즘의 효율성과 코드의 간결성을 위해 다음과 같은 전략을 사용했습니다.

- **상태의 정수 매핑**: `INCREASING`, `NEITHER`, `DECREASING` 상태를 각각 정수 `-1`, `0`, `1`으로 매핑합니다. 이는 문자열 비교 대신 정수 비교를 가능하게 하여 조건문의 가독성과 처리 효율을 높입니다. 직접 만든 `compare` 함수가 이 역할을 수행합니다.
- **결과 출력 최적화**: 최종 결과를 출력할 때, `if/elif/else` 조건 분기문을 사용하는 대신 배열과 인덱스를 활용합니다. 상태를 나타내는 정수(`-1`, `0`, `1`)에 1을 더하여 `[0, 1, 2]` 범위의 인덱스로 변환하고, 이를 사전에 정의된 결과 배열(`["INCREASING", "NEITHER", "DECREASING"]`)에 접근하는 데 사용합니다.

## **4. 전체 코드**
<details>
<summary>전체 코드 보기 (클릭하여 펼치기)</summary>
<div markdown="1">
```python
from sys import stdin, stdout

def compare(left, right):
    """
    두 문자열을 비교하여 정렬 상태를 나타내는 정수를 반환합니다.
    -1: 오름차순 (left < right)
     1: 내림차순 (left > right)
     0: 동일
    """
    if left < right:
        return -1
    elif left > right:
        return 1
    else:
        return 0

def main():
    # N과 이름 리스트 입력
    n = int(stdin.readline().rstrip())
    words = [stdin.readline().rstrip() for _ in range(n)]

    # 첫 두 요소를 기준으로 초기 방향성 설정
    direction = compare(words[0], words[1])

    # 리스트를 순회하며 정렬 일관성 검증
    for i in range(1, n - 1):
        if compare(words[i], words[i + 1]) != direction:
            direction = 0  # 일관성이 깨지면 NEITHER(0) 상태로 변경
            break

    # 상태 값에 따른 결과 문자열 매핑
    results = ["INCREASING", "NEITHER", "DECREASING"]
    # direction(-1, 0, 1)을 인덱스(0, 1, 2)로 변환하여 출력
    stdout.write(results[direction + 1])

if __name__ == "__main__":
    main()
```
</div>
</details>

## **5. 시간 복잡도 분석**

- **입력**: N개의 이름을 입력받는 데 O(N)의 시간이 소요됩니다.
- **탐색**: 리스트의 일관성을 검사하는 `for` 루프는 최악의 경우 N-2번 순회하므로 O(N)의 시간이 소요됩니다.

따라서, 이 알고리즘의 **최종 시간 복잡도는 O(N)**입니다. 공간 복잡도는 N개의 이름을 저장하기 위해 O(N)이 필요합니다.