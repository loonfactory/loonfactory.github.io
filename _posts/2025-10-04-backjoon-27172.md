---
layout: single
title:  "[백준 27172] 수 나누기 게임: C# 풀이 및 해설"
date:   2025-09-26 00:05 +0900
categories: [algorithm, baekjoon, csharp, 구현, 수학]
tags: [divisor, multiple, counting]
---

**문제 링크:** [수 나누기 게임](https://www.acmicpc.net/problem/27172)

## 1. 문제 개요

- 플레이어 수를 `n`이라 하고, **서로 다른** 자연수 `a1, a2, …, a_n`(각 값은 1 이상 1 000 000 이하)을 한 장씩 가진다.
- 두 플레이어 `i`와 `j`(`i ≠ j`)를 비교할 때  
  - `a_i`가 `a_j`의 **약수**라면
    - 플레이어 `i`는 **+1점**, 플레이어 `j`는 **−1점**을 얻는다. 
- 모든 쌍을 한 번씩 판정한 뒤, **각 플레이어의 최종 점수**를 처음 입력된 순서대로 출력한다.

---

## 2. 알고리즘 분석

### 2-1. 핵심 관찰

- **배수 관계**만 고려하면 된다.  
  - 값 `x`를 가진 카드가 있으면, `x`의 두 배,세 배,…처럼 `x`의 배수가 카드 목록에 존재하는지를 찾아 두 플레이어 점수를 갱신한다.  
- 카드 값의 최대치가 1000000이므로, **에라토스테네스 방식**으로 배수를 순회해도 시간이 충분하다.

### 2-2. 절차

1. **표시 배열** `counts[1..1000000]`
   - 카드가 존재하는 인덱스에 0을 넣어 “참여 중”임을 표시하고, 존재하지 않으면 `null`로 둔다.  
2. **배수 탐색**  
   - 각 카드 값 `v`에 대해 `2*v`, `3*v`, …를 순회하면서  
     - 해당 위치에 카드가 있으면 `counts[v]`를 1 증가, `counts[target]`을 1 감소시킨다.  
3. **출력**  
   - 처음 입력한 순서대로 `counts[a_i]` 값을 출력한다.

### 2-3. 복잡도

- “배수 탐색” 단계에서, **카드 값이 `v`인 항목마다** 최대 `1000000/v` 번 배수를 방문한다.  
  즉, 전체 작업 수는  
  > 모든 카드 값 `v`에 대해 `⌊1000000/v⌋` 을 합한 값  
- 입력 제한 `n ≤ 200000`에서도 충분히 빠르다.  
- **시간 복잡도**는 위 합계에 비례, **공간 복잡도**는 배열 하나(약 1 MB)로 `O(1000000)`.

---

## 3. 구현 전략

- **`int?[]` 배열**로 카드 존재 여부 및 점수를 함께 저장한다.  
  값이 없으면 `null`, 있으면 초기값 0.  
- **두 번의 `foreach`**  
  1. 카드 존재 표시  
  2. 다시 카드값을 돌며 배수 탐색  
- C#의 **버퍼링 I/O**(`StreamReader`, `StringWriter`)로 입출력 속도를 확보한다.

---

## 4. 전체 코드 (C# 11)

```csharp
using System.Text;

namespace Backjoon;

public static class Program
{
    public static void Solution(TextReader reader, TextWriter writer)
    {
        var n = int.Parse(reader.ReadLine()!);
        var inputs = Array.ConvertAll(reader.ReadLine()!.Split(), int.Parse);
        var range = 1000000;
        var counts = new int?[range + 1];
        foreach (var i in inputs)
        {
            counts[i] = 0;
        }

        foreach (var item in inputs)
        {
            for (var i = 2; item * i <= range; i++)
            {
                var target = item * i;
                if (counts[target] is not null)
                {
                    counts[target] -= 1;
                    counts[item] += 1;
                }
            }
        }

        writer.Write(string.Join(" ", inputs.Select(x => counts[x]!.Value)));
    }

    public static void Main()
    {
        using var reader = new StreamReader(new BufferedStream(Console.OpenStandardInput()));
        using var writer = new StringWriter(new StringBuilder());
        Solution(reader, writer);
        Console.Write(writer);
    }
}
```
---

## 5. 시간·공간 복잡도

| 단계 | 시간 | 공간 |
|------|------|------|
| 입력 파싱 | O(n) | O(n) |
| 배수 탐색 | “각 값 v에 대해 1000000/v 번”의 합계 | O(1000000) |
| 출력 | O(n) | — |
