---
layout: single
title:  "[백준 25044] 에어컨 문제: Python 풀이 및 해설"
date:   2025-09-23 23:00:00 +0900
categories: [Algorithm, Baekjoon]
tags: [Implementation, Simulation, Python]
---

**문제 링크:** [https://www.acmicpc.net/problem/25044](https://www.acmicpc.net/problem/25044)

## 1. 문제 개요

에어컨은 매일 **15시, 18시, 21시** 정각에 자동으로 꺼집니다.  
세 번째(21시)마다 내장 시계가 **K 분**만큼 멈추기 때문에, 이후 모든 꺼짐 시각이 K 분씩 뒤로 밀린 상태로 반복됩니다.

> 목표: `N` 일째(0 일 = 오늘) 에어컨이 꺼지는 **모든 시각**을 예측해 출력한다.

## 2. 알고리즘 분석

### 2‑1. 간격 패턴 도출
- 15 시 → 18 시 : **3 시간** = 180 분  
- 18 시 → 21 시 : **3 시간** = 180 분  
- 21 시 → 다음날 15 시: **18 시간 + K 분** = 1080 분 + K  

따라서 **`[180, 180, 1080+K]`** 분 주기가 무한 반복된다.

### 2‑2. 시뮬레이션
1. **시간 단위 통일**: 0 일 00:00을 기준으로 분(min) 단위 누적 시간 `t` 사용  
2. **첫 이벤트**: `t = 15 × 60 = 900` (0 일 15 시)  
3. **루프**:  
   - `t`가 `N` 일 범위를 벗어날 때까지 `dt[offset]`를 더하며 이벤트 생성  
   - `N · 1440 ≤ t < (N+1) · 1440` 이면 결과 배열에 저장

### 2‑3. 복잡도
- 이벤트 수 ≤ **3 × (N + 1)** → 시간 O(N)  
- 결과는 최대 3개 → 공간 O(1)

## 3. 구현 전략

| 요소 | 설명 |
|-----|------|
| **간격 배열** | `dt = (180, 180, 1080 + k)` |
| **순환 인덱스** | `idx = (idx + 1) % 3` 로 0→1→2→0 반복 |
| **시각 포맷** | `"{(t % (24 * 60))//60:02}:{t%60:02}"` |

## 4. 전체 코드

```python
from sys import stdin, stdout

def main():
    inputs = list(map(int, stdin.readline().rstrip().split()))
    n, k = inputs[0], inputs[1]
    dt = [3 * 60, 3 * 60, 18 * 60 + k]      # [180, 180, 1080+K]
    offset = 0                              # dt 인덱스
    t = 15 * 60                             # 0일 15:00 → 900분
    startTime = n * 24 * 60                 # N·1440
    endTime = startTime + 24 * 60           # (N+1)·1440
    result = []

    while t < endTime:
        if startTime <= t:
            result.append(t)
        t += dt[offset]
        offset = (offset + 1) % len(dt)

    print(len(result))
    print(*map(lambda x: f"{(x % (24 * 60))//60:02}:{x%60:02}", result), sep="\n")

if __name__ == "__main__":
    main()
```

## 5. 시간·공간 복잡도 분석

- **시간**: 이벤트마다 상수 연산 → 최대 `3(N+1)` 회 ⇒ **O(N)**  
- **공간**: 결과 시각(≤3개)만 저장 ⇒ **O(1)**
